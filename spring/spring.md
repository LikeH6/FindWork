https://www.bilibili.com/video/BV1Z44y1q7wf?from=search&seid=1696733851067838469

# spring是什么

轻量级的开源的J2EE框架。它是一个容器框架，用来装JavaBean（Java对象），还是一个中间层框架，可以起一个连接作用，比如说把struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简洁。

Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架

- 从大小和开销两方面而言，spring都是轻量级的
- 通过控制反转的技术达到松耦合的目的
- 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统服务进行内聚性的开发
- 包含并管理应用对象（Bean）的配置和生命周期，这个意义上是一个容器
- 将简单的组件配置、组合为复杂的应用，这个意义上是一个框架

# 谈谈你对AOP的理解

系统是由许多不同的组件所组成的，每一个组件各复制一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务功能逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。

当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。

日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。

在OOP设计中，它导致了大量代码的重复，而且不利于各个模块的重用。

**AOP：**将程序中的交叉业务逻辑（比如安全、日志、事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外做一些事情。

# 谈谈你对IOC的理解

从容器概念、控制反转、依赖注入三方面理解。

**IOC容器**：实际上就是一个map（key、value），里面存的是各种对象（在xml里配置的bean节点、@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。

这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI（依赖注入）注入（autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或者id注入；id就是对象名）

**控制反转：**

没有引入IOC容器前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用以及创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。

引入IOC容器后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，**IOC容器会主动创建一个对象B注入到对象A需要的地方。**

通过前后对比，不难看出：对象A获得依赖对象B的过程，由主动行为变为了被动行为，控制权颠倒过来了。这就是“控制反转”这个名称的由来。

全部对象的控制权全部上缴给”第三方"IOC容器，所以IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。

**依赖注入：**

“获得依赖对象的过程被反转了”。控制被反转后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象中。

# BeanFactory和ApplicationContext有什么区别

ApplicationContext是BeanFactory的子接口

ApplicationContext提供了更完整的功能：

​	1、继承MessageSource，因此支持国际化

​	2、统一的资源文件访问方式

​	3、提供在监听器中注册bean的事件

​	4、同时加载多个配置文件

​	5、载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特点的层次，比如应用的web层

BeanFactory采用的是**延迟加载形式**来注入Bean的，即只有在使用到某个Bean的时候（调用getBean()），才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFactory加载后，直至第一次使用调用getBean()方法才回抛出异常。

ApplicationContext，它是在容器启动的时候，一次性创建了所有的Bean。这样，在容器启动的时候，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean，确保当你需要的时候，你就不用等待，因为它们已经创建好了。

相对于基本的BeanFactory，ApplicationContext唯一的不足是占用内存空间。当应用程序配置bean较多时，程序启动较慢。

BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。

BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但是两者的区别是：BeanFactory需要手动注册，ApplicationContext则是自动注册。

# 简述bean的生命周期

1. 解析类得到BeanDefinition

2. 如果有多个构造方法，则要推断构造方法
3. 确定好构造方法后，进行实例化得到一个对象
4. 对对象中的加了@Autowried注解的属性进行属性填充
5. 回调Aware方法，比如BeanNameAware、BeanFactoryAware
6. 调用BeanPostProcessor的初始化前的方法
7. 回调初始化方法
8. 调用BeanPostProcessor的初始化后的方法，在这里会进行AOP
9. 如果当前创建的bean是单例的，则会把bean放入单例池
10. 在运行期间使用bean
11. Spring容器关闭时调用DisposableBean中的destory()方法

# spring的

