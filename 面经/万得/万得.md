# List、Set、Map的区别和联系

# HashMap底层



# 红黑树的特征

（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。[这里指到叶子节点的路径]

# 多线程了解吗？怎么使用

java中线程的主要实现方式有三种:

==继承Thread类==：将类声明为Thread的子类，这个子类应该重写run类的方法Thread，然后可以分配并启动子类的实例。Thread内部也是继承了Runnable接口

==实现Runnable接口==：声明实现类Runnable接口，那个类实现了run方法，然后可以分配类的实例，在创建Thread时作为参数传递，并启动

使用继承Thread类的方式创建线程时，最大的局限是不支持多继承，因为java语言的特点是单继承，所以为了实现支持多继承，可以实现Runnable接口，即一边实现一边继承，但这两种方式创建线程的功能是一样的，没有本质的区别。

==实现Callable接口==：

# synchronized和lock的区别

- synchronized是关键字，内置语言实现，Lock是接口

- Lock是显示锁，需要手动开启和释放锁（通常在finally中释放），synchronized是隐式锁，出了作用域自动释放锁

- Lock只有代码块锁，而synchronized有代码块锁和方法锁

- 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性

- Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。

  Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。

# 动态规划的基本流程（状态转移方程、临界条件...）

找到 状态和选择 -> 明确 dp 数组/函数的定义 -> 寻找状态之间的关系

# spring你怎么理解的

# 如果要你实现spring容器你会怎么做

# mysql索引了解哪些

# hash索引和b+索引优劣分析

**hash索引**
1:hash索引进行等值查询更快(一般情况下)但是却无法进行范围查询.因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.

2:hash索引不支持模糊查询以及多列索引的最左前缀匹配,因为hash函数的不可预测,eg:AAAA和AAAAB的索引没有相关性.

3:hash索引任何时候都避免不了回表查询数据.

4:hash索引虽然在等值上查询叫快,但是不稳定,性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时查询效率可能极差.

5:hash索引不支持使用索引进行排序,因为hash函数的不可预测.

**B+树**
1:B+树的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似)自然支持范围查询.

2:在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.不需要回表查询.

3:查询效率比较稳定,对于查询都是从根节点到叶子节点,且树的高度较低.

# 数据库事务？隔离级别？可重复读咋实现？

# 谈一下进程线程

# 进程同步和互斥

# redis基本数据类型

# 为什么使用redis

- 性能极高 – Redis读的速度是110000次/s,写的速度是81000次/s 。
- 丰富的数据类型 – Redis支持Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
- 原子 – Redis的所有操作都是原子性的，即要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。
- 丰富的特性 – Redis还支持publish/subscribe, key过期等特性。

# rabbitmq一些协议说一下

# 说几个常见的设计模式

# 面向对象的设计原则

# 数据库范式

# 数据库事务的使用？ACID？

# springboot优缺点？

## Spring Boot 核心功能

1）独立运行的 Spring 项目

Spring Boot 可以以 jar 包的形式独立运行，运行一个 Spring Boot 项目只需通过 java–jar xx.jar 来运行。

2）内嵌 Servlet 容器

Spring Boot 可选择内嵌 Tomcat、Jetty 或者 Undertow，这样我们无须以 war 包形式部署项目。

3）提供 starter 简化 Maven配置

Spring 提供了一系列的 starter pom 来简化 Maven 的依赖加载，例如，当你使用了spring-boot-starter-web 时，会自动加入如图 1 所示的依赖包。

4）自动配置 Spring

Spring Boot 会根据在类路径中的 jar 包、类，为 jar 包里的类自动配置 Bean，这样会极大地减少我们要使用的配置。当然，Spring Boot 只是考虑了大多数的开发场景，并不是所有的场景，若在实际开发中我们需要自动配置 Bean，而 Spring Boot 没有提供支持，则可以自定义自动配置。

5）准生产的应用监控

Spring Boot 提供基于 http、ssh、telnet 对运行时的项目进行监控。

6）无代码生成和 xml 配置

Spring Boot 的神奇的不是借助于代码生成来实现的，而是通过条件注解来实现的，这是 Spring 4.x 提供的新特性。Spring 4.x 提倡使用 Java 配置和注解配置组合，而 Spring Boot 不需要任何 xml 配置即可实现 Spring 的所有配置。

## 优缺点

1）优点

- 快速构建项目。
- 对主流开发框架的无配置集成。
- 项目可独立运行，无须外部依赖Servlet容器。
- 提供运行时的应用监控。
- 极大地提高了开发、部署效率。
- 与云计算的天然集成。

2）缺点

- 版本迭代速度很快，一些模块改动很大。
- 由于不用自己做配置，报错时很难定位。
- 网上现成的解决方案比较少。

# 谈谈分布式

