# 介绍项目

# 标注系统的主要难点在什么地方

# 鼠标点击的时候如何跟文本关联起来

# 标注系统的整体结构

# 为什么使用docker部署

首先，Docker的使用简单至极，从开发的角度来看就是三步走：构建，运输，运行。其中关键步骤就是构建环节，即打包镜像文件。但是从测试和运维的角度来看，那就只有两步：复制，运行。有了这个镜像，那么想复制到哪运行都可以，完全和平台无关了。同时Docker这种容器技术隔离出了独立的运行空间，不会和其他应用争用系统资源了以及还不需要考虑应用之间相互影响，想想就开心。

其次，因为在构建镜像的时候就处理完了服务程序对于系统的所有依赖，所以在你使用的时候，你可以忽略掉原本程序的依赖以及开发语言。对测试和运维而言，更多专注于自己的业务内容上。

最后，Docker于开发者而言提供了一种开发环境的管理办法，与测试人员而言保证了环境的同步，于运维人员提供了可移植的标准化部署流程。

# 在docker部署了什么东西，怎么部署的

# 如果项目镜像启动两个，系统是否能够正常运行

# 项目本身支不支持两个实例同时启动

# 微服务中一个服务需要开启两个实例需要满足什么条件

# python和java开发有什么区别

# java的语言特性

比如面向对象是什么样的概念

封装、继承、多态

为什么要封装

# java如何实现多继承

Java 提供的两种方法让我们实现多重继承：接口和内部类。

**内部类**：定义两个内部类，这两个内部类分别继承 Father（父亲）类和 Mother（母亲）类，且都可以获取各自父类的行为。这是内部类一个很重要的特性：内部类可以继承一个与外部类无关的类，从而保证内部类的独立性。正是基于这一点，多重继承才会成为可能。

```java
// 创建 Father 类
public class Father {
    public int strong() {   
        // 强壮指数
        return 9;
    }
}
// 创建 Mother 类
public class Mother {
    public int kind() {    
        // 友好指数
        return 8;
    }
}
// 创建 Son 类，在该类中通过内部类实现多重继承
public class Son {
    // 内部类继承Father类
    class Father_1 extends Father {
        public int strong() {
            return super.strong() + 1;
        }
    }
    // 内部类继承Mother类
    class Mother_1 extends Mother {
        public int kind() {
            return super.kind() - 2;
        }
    }
    public int getStrong() {
        return new Father_1().strong();
    }
    public int getKind() {
        return new Mother_1().kind();
    }
}
```



# springcloud用了哪些组件

# 拆分服务的时候为什么这样拆

# 描述一下GC

# 为什么要有GC

Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。Java有了GC，就不需要程序员去人工释放内存空间。当Java虚拟机发觉内存资源紧张的时候，就会自动地去清理无用变量所占用的内存空间。当然，如果需要，程序员可以在Java程序中显式地使用System.gc()来强制进行一次立即的内存清理。

# 为什么会出现内存溢出

编写java程序最为方便的地方就是我们不需要管理内存的分配和释放，一切由jvm来进行处理，当java对象不再被应用时，等到堆内存不够用时，jvm会进行垃圾回收，清除这些对象占用的堆内存空间，如果对象一直被应用，jvm无法对其进行回收，创建新的对象时，无法从Heap中获取足够的内存分配给对象，这时候就会导致内存溢出。而出现内存泄露的地方，一般是不断的往容器中存放对象，而容器没有相应的大小限制或清除机制。容易导致内存溢出。

# 清除了对象后，如果后续还需要使用，那怎么办

# 为什么会有弱引用

弱引用（Weak Reference）：弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了**只具有弱引用**的对象，不管当前内存空间足够与否，都会回收它的内存

Java常通过使用弱引用来避免内存泄漏。

# threadlocal中的value因为强引用存在久而久之为什么会导致内存溢出？？？？

可能我说法有问题，我说成了 threadlocal中的value因为强引用存在，不会被回收，所以导致久而久之就会出现内存溢出。



