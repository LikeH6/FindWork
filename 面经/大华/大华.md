# override和overload的区别

**重写Override**：

Override表示子类中的方法可以与父类中的某个方法的**名称和参数完全相同**，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的**多态性**的一种表现。子类覆盖父类的方法时，**只能比父类抛出更少的异常**，或者是**抛出父类抛出的异常的子异常**，因为子类可以解决父类的一些问题，不能比父类有更多的问题。**子类方法的访问权限只能比父类的更大**，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。

注意：

1.覆盖的方法的标志必须要和被覆盖的方法的**标志完全匹配**，才能达到覆盖的效果；

2.覆盖的方法的返回值必须和被覆盖的方法的**返回值一致**；

3.覆盖的方法所抛出的异常必须和被覆盖方法的**所抛出的异常一致**，或者是其**子类**；

4.被覆盖的方法**不能为private**，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。

**重载Overload**：

Overload表示**同一个类中可以有多个名称相同的方法**，但这些方法的**参数列表各不相同**，即参数个数或类型不同。

注意：

1.如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。

2.如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload？答案是不行的。例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它**无法通过返回结果类型来判断**。

# final，finalize，finally的区别

**1.简单区别：**
**final**用于声明属性，方法和类，分别表示属性不可改变，方法不可覆盖，类不可继承。
**finally**是异常处理语句结构的一部分，表示总是执行。
**finalize**是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。
**2.中等区别：**
虽然这个单词在Java中都存在，但是并没太多关联：
**final：**java中的关键字，修饰符。
A).如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。
B).如果将变量或者方法声明为final，可以保证它们在使用中不被改变.
　　1)被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。
　　2)被声明final的方法只能使用，不能重载。
**finally：**java的一种异常处理机制。return、continue和break都没能阻止finally语句块的执行。
　　finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。
**finalize：**Java中的一个方法名。
Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。

finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception），GC将终止对该对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。

# Integer类能否被继承

下列是java.lang包中不能被继承的类：

```java
public final class Byte  //基本数据类型的包装类
public final class String  
public final class Double  
public final class Float  
public final class Integer 
public final class Short   
public final class Long  
public final class Math  
public final class Character  
public static final class Character.UnicodeBlock  
public final class Class<T>  
public final class Compile  //编译器
public final class ProcessBuilder  
public final class RuntimePermission  //运行权限
public final class StackTraceElement  //堆栈跟踪元素
public final class StrictMath  //严格数学
public final class StringBuffer  
public final class StringBuilder  
public final class System  
public final class Void  

```

# 抽象类和接口有什么区别

接口和抽象类的相同点：

(1) 都可以被继承

(2) 都不能被实例化

(3) 都可以包含方法声明

(4) 派生类必须实现未实现的方法

接口和抽象类的区别：

（1）抽象类可以有构造方法，接口中不能有构造方法。

（2）抽象类中可以有普通成员变量，接口中没有普通成员变量

（3）抽象类中可以包含静态方法，接口中不能包含静态方法

（4） 一个类可以实现多个接口，但只能继承一个抽象类。

（5）接口可以被多重实现，抽象类只能被单一继承

（6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法


 # static的用法

# 调用run方法和start方法有什么区别

调用 start() 方法是用来启动线程的，轮到该线程执行时，会自动调用 run()；直接调用 run() 方法，无法达到启动多线程的目的，相当于主线程线性执行 Thread 对象的 run() 方法。

一个线程的 start() 方法只能调用一次，多次调用会抛出 java.lang.IllegalThreadStateException 异常；run() 方法没有限制。

# 什么时候使用run方法

如果这个线程是使用Runnable对象构造的，那么实际上是调用的Runnable对象的run方法；否则的话，方法不做任何处理。Thread类的子类应该重写该方法。

上面的内容可以进一步补充一下，因为Thread类自身继承了Runnable接口，因此也可以采用继承了Thread的一个类的对象作为参数传入，构造Thread实例，这种情况下，实际上调用的则是该传入的Thread对象的run方法。

MyThread.java类的构造函数是被main线程调用的，启动start()后的隐式调用的run方法是被创建的名叫myThread线程调用的，而显式调用的run方法则是main线程调用的。

# 什么是MVCC

全称Multi-Version Concurrency Control，即多版本并发控制。主要是为了提高数据库的并发性能。MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

MVCC只在 READ COMMITTED（读已提交） 和 REPEATABLE READ（可重复读） 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED （读未提交）总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。

它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View (读视图) 来实现的。

# sql如何调优

一、创建索引

1、要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引

2、在经常需要进行检索的字段上创建索引

二、避免在索引上使用计算

在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引。

三、用where字句替换HAVING字句

避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。

四、使用表的别名

当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减
少哪些友列名歧义引起的语法错误。

五、查询select语句优化

1.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段
2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，

# mysql事务一致性

一致性是指数据处于一种语义上的有意义且正确的状态。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。

原子性和一致性的的侧重点不同：**原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。**而**一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见**

一致性是要保证操作前和操作后数据或者数据结构的一致性，而我提到的事务的一致性是**关注**数据的中间状态，也就是一致性需要监视中间状态的数据，如果有变化，即刻回滚

# redis高可用

在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。

在Redis中，实现高可用的技术主要包括持久化、复制、哨兵和集群，下面分别说明它们的作用，以及解决了什么样的问题。

1. 持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。
2. 复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
3. 哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。
4. 集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。****

# redis持久化

持久化的功能：Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。

Redis持久化分为RDB（Redis DataBase）持久化和AOF（Append Only File）持久化**：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）；**由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。

RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。RDB持久化的触发分为手动触发和自动触发两种。

AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog）；当Redis重启时再次执行AOF文件中的命令来恢复数据。

# 在MySQL中你怎么实现一个乐观锁

1、使用**版本控制字段**，再利用行锁的特性实现乐观锁。即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。

当我们提交更新的时候，判断数据库表对应记录 的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据

2、乐观锁定的第二种实现方式和第一种差不多，**同样是在需要乐观锁控制的table中增加一个字段**，名称无所谓，字段类型使用**时间戳** （timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

# 聚簇索引和非聚簇索引的区别

InnoDB的默认数据结构是聚簇索引，而MyISAM是非聚簇索引。

聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据

非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置

聚簇索引（Clustered Index）并不是一种单独的索引类型，而是一种数据存储方式。当表有了聚簇索引的时候，表的数据行都存放在索引树的叶子页中。无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引。InnoDB的聚簇索引实际上是将索引和数据保存中同一个B-Tree中。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

非聚簇索引（NoClustered Index），又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。

# B+树的原理

# 如何排查是什么原因导致CPU占用率过高

1.先用top命令,找到cpu占用最高的进程 PID 

2.再用ps -mp pid -o THREAD,tid,time  查询进程中,那个线程的cpu占用率高 记住TID

3.jstack 29099 >> xxx.log  打印出该进程下线程日志

4.sz xxx.log 将日志文件下载到本地

5.将查找到的 线程占用最高的 tid 上上上图中 29108  转成16进制 --- 71b4

6.打开下载好的 xxx.log 通过 查找方式 找到 对应线程 进行排查

容易出现cpu占用过高的几点

​	1.代码中写死循环时,一直占用cpu

​	2.在循环中不停的创建对象,也会导致GC频繁

​	3.System.currentTimeMillis() 采用这种方式去做计时,大概占用了10-20%cpu,因为不停的调用

​	4.C2 CompilerThread0 --这个线程大概在进程启动前一段时间会占用 10-20%cpu,后面会下降到1%

# Runnbale和Callable区别

(1) Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。

(2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。

(3) call方法可以抛出异常，run方法不可以。

(4) 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果future.get()。


相同点：

​	都是接口

​	都可以编写多线程程序

​	都采用Thread.start()启动线程

不同点：

​	Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果

​	Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛

​	**注**：Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。

# Java反射

什么是反射？

​	**反射就是把java类中的各种成分映射成一个个的Java对象**

​	Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态（或准动态，为啥要说是准动态，因为一般而言的动态语言定义是程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。）语言的一个关键性质。

反射能做什么？ 　　

　　我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗

得到class的三种方法：

```java
//1、通过对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object
//  类型的对象，而我不知道你具体是什么类，用这种方法
　　Person p1 = new Person();
　　Class c1 = p1.getClass();

//2、直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高
//  这说明任何一个类都有一个隐含的静态成员变量 class
　　Class c2 = Person.class;

//3、通过 Class 对象的 forName() 静态方法来获取，用的最多，
//   但可能抛出 ClassNotFoundException 异常
　　Class c3 = Class.forName("com.ys.reflex.Person");
```

需要注意的是：**一个类在 JVM 中只会有一个 Class 实例,**即我们对上面获取的 c1,c2,c3进行 equals 比较，发现都是true

# SQL注入

**什么是sql注入？**

SQL 注入（SQL Injection）是发生在 Web 程序中数据库层的安全漏洞，是网站存在最多也是最简单的漏洞。主要原因是程序对用户输入数据的合法性没有判断和处理，导致攻击者可以在 Web 应用程序中事先定义好的 SQL 语句中添加额外的 SQL 语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步获取到数据信息。

简而言之，SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。

**SQL注入的原理**

1）恶意拼接查询

我们知道，SQL 语句可以查询、插入、更新和删除数据，且使用分号来分隔不同的命令。例如：

```sql
SELECT * FROM users WHERE user_id = $user_id
```

其中，user_id 是传入的参数，如果传入的参数值为“1234; DELETE FROM users”，那么最终的查询语句会变为：

```sql
SELECT * FROM users WHERE user_id = 1234; DELETE FROM users
```

2）利用注释执行非法命令

SQL 语句中可以插入注释。例如：

```sql
SELECT COUNT(*) AS 'num' FROM game_score WHERE game_id=24411 AND version=$version
```

如果 version 包含了恶意的字符串`'-1' OR 3 AND SLEEP(500)--`，那么最终查询语句会变为：

```sql
SELECT COUNT(*) AS 'num' FROM game_score WHERE game_id=24411 AND version='-1' OR 3 AND SLEEP(500)--
```

以上恶意查询只是想耗尽系统资源，SLEEP(500) 将导致 SQL 语句一直运行。如果其中添加了修改、删除数据的恶意指令，那么将会造成更大的破坏。

3）传入非法参数

SQL 语句中传入的字符串参数是用单引号引起来的，如果字符串本身包含单引号而没有被处理，那么可能会篡改原本 SQL 语句的作用。 例如：

```sql
SELECT * FROM user_name WHERE user_name = $user_name
```

如果 user_name 传入参数值为 G'chen，那么最终的查询语句会变为：

```sql
SELECT * FROM user_name WHERE user_name ='G'chen'
```

一般情况下，以上语句会执行出错，这样的语句风险比较小。虽然没有语法错误，但可能会恶意产生 SQL 语句，并且以一种你不期望的方式运行。

4）添加额外条件

在 SQL 语句中添加一些额外条件，以此来改变执行行为。条件一般为真值表达式。例如：

```sql
UPDATE users SET userpass='$userpass' WHERE user_id=$user_id;
```

如果 user_id 被传入恶意的字符串“1234 OR TRUE”，那么最终的 SQL 语句会变为：

```sql
UPDATE users SET userpass= '123456' WHERE user_id=1234 OR TRUE;
```

这将更改所有用户的密码。

**避免SQL注入**

对于 SQL 注入，我们可以采取适当的预防措施来保护数据安全。下面是避免 SQL 注入的一些方法。

1. 过滤输入内容，校验字符串

过滤输入内容就是在数据提交到数据库之前，就把用户输入中的不合法字符剔除掉。可以使用编程语言提供的处理函数或自己的处理函数来进行过滤，还可以使用正则表达式匹配安全的字符串。

如果值属于特定的类型或有具体的格式，那么在拼接 SQL 语句之前就 要进行校验，验证其有效性。比如对于某个传入的值，如果可以确定是整型，则要判断它是否为整型，在浏览器端（客户端）和服务器端都需要进行验证。

2. 参数化查询

参数化查询目前被视作是预防 SQL 注入攻击最有效的方法。参数化查询是指在设计与数据库连接并访问数据时，在需要填入数值或数据的地方，使用参数（Parameter）来给值。

MySQL 的参数格式是以“?”字符加上参数名称而成，如下所示：

UPDATE myTable SET c1 = ?c1, c2 = ?c2, c3 = ?c3 WHERE c4 = ?c4

在使用参数化查询的情况下，数据库服务器不会将参数的内容视为 SQL 语句的一部分来进行处理，而是在数据库完成 SQL 语句的编译之后，才套用参数运行。因此就算参数中含有破坏性的指令，也不会被数据库所运行。

3. 安全测试、安全审计

除了开发规范，还需要合适的工具来确保代码的安全。我们应该在开发过程中应对代码进行审查，在测试环节使用工具进行扫描，上线后定期扫描安全漏洞。通过多个环节的检查，一般是可以避免 SQL 注入的。

有些人认为存储过程可以避免 SQL 注入，存储过程在传统行业里用得比较多，对于权限的控制是有一定用处的，但如果存储过程用到了动态查询，拼接 SQL，一样会存在安全隐患。

**在开发过程中可以避免 SQL 注入的一些方法**

1. 避免使用动态SQL

避免将用户的输入数据直接放入 SQL 语句中，最好使用准备好的语句和参数化查询，这样更安全。

2. 不要将敏感数据保留在纯文本中

加密存储在数据库中的私有/机密数据，这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。

3. 限制数据库权限和特权

将数据库用户的功能设置为最低要求；这将限制攻击者在设法获取访问权限时可以执行的操作。

4. 避免直接向用户显示数据库错误

攻击者可以使用这些错误消息来获取有关数据库的信息。

# Redis 缓存雪崩 及其拯救措施

缓存雪崩通俗简单的理解就是：由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取，如下图）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。

数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。

缓存雪崩的事前、事中和事后的应对措施：

1.事前：redis 高可用（主从 + 哨兵、redis cluster），避免全盘崩溃。

​	缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。

2.事中：本地 ehcache 缓存 + hystrix（网络）限流 & 降级，避免MySQL打死。

​	可以利用ehcache等本地缓存(暂时支持)，但主要还是对源服务访问进行限流、资源隔离（熔断）、降级等。

​	当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行**自动降级**，也可以配置开关实现**人工降级，**这里会涉及到运维的配合。

​	降级的最终目的是保证核心服务可用，即使是有损的。

3.事后：redis 数据持久化，一旦 重启，自动从磁盘上加载数据，快速恢复缓存数据。

# Redis缓存穿透

缓存穿透是指查询一个不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

**解决思路：**

如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。 

可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。

# Redis缓存击穿

缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。

不同场景下的解决方式可如下：

- 若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
- 若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。
- 若缓存的数据更新频繁或者缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动的重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。

# HashMap底层实现架构

**HashMap的底层实现是数组+链表+红黑树的形式的，同时它的数组的默认初始容量是16、扩容因子为0.75，每次采用2倍的扩容**。也就是说，每当我们数组中的存储容量达到75%的时候，就需要对数组容量进行2倍的扩容。

 对于HashMap中链表元素的存储，在JDK1.7以及前是在头结点插入的，在JDK1.8之后是在尾节点插入的。

# 线程池的分类和作用

## 1、newCachedThreadPool

作用：创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。

特征： 
（1）线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE） 
（2）线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟） 
（3）当线程池中，没有可用线程，会重新创建一个线程

创建方式： Executors.newCachedThreadPool();

## 2、newFixedThreadPool

作用：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。

特征： 
（1）线程池中的线程处于一定的量，可以很好的控制线程的并发量 
（2）线程可以重复被使用，在显示关闭之前，都将一直存在 
（3）超出一定量的线程被提交时候需在队列中等待

创建方式： 
（1）Executors.newFixedThreadPool(int nThreads)；//nThreads为线程的数量 
（2）Executors.newFixedThreadPool(int nThreads，ThreadFactory threadFactory)；//nThreads为线程的数量，threadFactory创建线程的工厂方式

## 3、newSingleThreadExecutor

作用：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。

特征： 
（1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行

创建方式： 
（1）Executors.newSingleThreadExecutor() ； 
（2）Executors.newSingleThreadExecutor(ThreadFactory threadFactory)；// threadFactory创建线程的工厂方式

## 4、newScheduleThreadPool

作用： 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

特征： 
（1）线程池中具有指定数量的线程，即便是空线程也将保留 
（2）可定时或者延迟执行线程活动

创建方式： 
（1）Executors.newScheduledThreadPool(int corePoolSize)；// corePoolSize线程的个数 
（2）newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)；// corePoolSize线程的个数，threadFactory创建线程的工厂

## 5、newSingleThreadScheduledExecutor

作用： 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。

特征： 
（1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行 
（2）可定时或者延迟执行线程活动

创建方式： 
（1）Executors.newSingleThreadScheduledExecutor() ； 
（2）Executors.newSingleThreadScheduledExecutor(ThreadFactory threadFactory) ；//threadFactory创建线程的工厂

# 线程池参数，过程

## 七大参数

（1）corePoolSize：线程池中的常驻核心线程数。

（2）maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值大于等于1。

（3）keepAliveTime：多余的空闲线程存活时间，当空间时间达到keepAliveTime值时，多余的线程会被销毁直到只剩下corePoolSize个线程为止。

（4）unit：keepAliveTime的单位。

（5）workQueue：任务队列，被提交但尚未被执行的任务。

（6）threadFactory：表示生成线程池中工作线程的线程工厂，用户创建新线程，一般用默认即可。

（7）handler：拒绝策略，表示当线程队列满了并且工作线程大于等于线程池的最大显示数(maxnumPoolSize)时如何来拒绝请求执行的runnable的策略。

## 主要参数

**corePoolSize**

核心线程数，该参数说明了在线程池中保持核心线程的数量，由自己定义，刚创建线程池时，里面的核心线程数为0，随着任务的添加，达到核心线程数，执行完任务之后，线程池里面的核心线程数一直维持在设置的核心线程数。

**maximumPoolSize**

最大线程数，该参数定义了一个线程池中最多能容纳多少个线程。当一个任务提交到线程池中时，如果线程数量达到了核心线程数，并且任务队列已满，不能再向任务队列中添加任务时，这时会检查任务是否达到了最大线程数，如果未达到，则创建新线程，执行任务，否则，执行拒绝策略。

**keepAliveTime**

（最大线程数—核心线程数）线程存活时间，线程池中大于核心线程数的那部分线程，即线程数总数量减去核心线程数的那部分线程，在执行完任务之后，在线程池中存活的时间。

**workQueue**

任务队列，用来做缓冲作用，当提交到线程池中的任务核心线程数量不够用时，所有的核心线程都在执行任务，会将任务存到任务队列中，等待核心线程 来执行。该参数主要是在核心线程数都在执行任务时，才起作用的参数，主要用来缓存任务。

## 过程

用户提交任务，查看核心线程池是否满，没满则创建线程，执行任务，满了则交给缓冲队列，缓冲队列没满，则将任务添加到队列，满了，则判断最大线程池是否满了，没满则创建线程，执行任务，满了则拒绝策略

![image-20210726102530408](.\image\image-20210726102530408.png)

# 双亲委派机制

## 工作过程

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己加载。

## 打破双亲委派机制

在BootstrapClassLoader或ExtClassLoader加载的类A中如果使用到AppClassLoader类加载器加载的类B，由于双亲委托机制不能向下委托，那可以在类A中通过线程上下文类加载器获得AppClassLoader，从而去加载类B，这不是委托，说白了这是作弊，也是JVM为了解决双亲委托机制的缺陷不得已的操作！ 

线程上下文类加载器（Thread Context ClassLoader）：这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

## 优缺点

**优点**

- 避免类的重复加载， 确保一个类的全局唯一性。使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的加载器一起具备了一种带有优先级的层次关系。

- 保护程序安全， 防止核心 API 被随意篡改

**缺点**

检查类是否加载的委派过程是单向的， 这个方式虽然从结构上说比较清晰，使各个 ClassLoader 的职责非常明确， 但是同时会带来一个问题， 即顶层的ClassLoader 无法访问底层的 ClassLoader 所加载的类

# docker查看容器的日志

通过docker logs命令可以查看容器的日志。

# 栈溢出（StackOverflowError）以及例子

如果线程请求的栈深度大于虚拟机允许的深度，就会抛出StackOverflowError异常

例子：递归。因为每调用一个方法就会在栈上创建一个栈帧，方法调用结束后就会弹出该栈帧，而栈的大小不是无限的，所以递归调用次数过多的话就会导致栈溢出。而递归调用的特点是每递归一次，就要创建一个新的栈帧，而且还要保留之前的环境（栈帧），直到遇到结束条件。所以递归调用一定要明确好结束条件，不要出现死循环，而且要避免栈太深。

# redis的优缺点

redis是一个key-value存储系统，数据存储在内存中，它的优点主要如下：

1. 支持多种数据类型：包括set,zset,list,hash,string这五种数据类型，操作非常方便。比如，如果你在做好友系统，查看自己的好友关系，如果采用其他的key-value系统，则必须把对应的好友拼接成字符串，然后在提取好友时，再把value进行解析，而redis则相对简单，直接支持list的存储(采用双向链表或者压缩链表的存储方式)。
2. 持久化存储：作为一个内存数据库，最担心的，就是万一机器死机，数据会消失掉。redi使用rdb和aof做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。
3. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除；pub/sub，key过期策略，事务，支持多个DB等。
4. 性能很好：由于是全内存操作，所以读写性能很好，可以达到10w/s的频率。公司有项目使用redis，目前的访问频率是80w/s，通过适当的部署，线上运行一切ok。

redis的缺点主要如下：

1. 由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
2. 如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。
3. 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能提供服务。

# 如何设计一个缓存

考虑点主要在数据用何种方式存储，能存储多少数据，多余的数据如何处理等几个点

**1.数据结构**

一样提供了多种数据类型哈希，列表，集合，有序集合等，底层使用了双端链表，压缩列表，集合，跳跃表等数据结构；

**2.对象上限**

因为是本地缓存，内存有上限，所以一般都会指定缓存对象的数量比如1024，当达到某个上限后需要有某种策略去删除多余的数据；

**3.清除策略**

上面说到当达到对象上限之后需要有清除策略，常见的比如有LRU(最近最少使用)、FIFO(先进先出)、LFU(最近最不常用)、SOFT(软引用)、WEAK(弱引用)等策略；

**4.过期时间**

除了使用清除策略，一般本地缓存也会有一个过期时间设置，比如redis可以给每个key设置一个过期时间，这样当达到过期时间之后直接删除，采用清除策略+过期时间双重保证；常见的过期数据删除策略有两种方式：被动删除和主动删除；被动删除：每次进行get/put操作的时候都会检查一下当前key是否已经过期，如果过期则删除，

**5.线程安全**

像redis是直接使用单线程处理，所以就不存在线程安全问题；而我们现在提供的本地缓存往往是可以多个线程同时访问的，所以线程安全是不容忽视的问题；并且线程安全问题是不应该抛给使用者去保证；

**6.简明的接口**

提供一个傻瓜式的对外接口是很有必要的，对使用者来说使用此缓存不是一种负担而是一种享受；提供常用的get，put，remove，clear，getSize方法即可；

**7.是否持久化**

这个其实不是必须的，是否需要将缓存数据持久化看需求；本地缓存如ehcache是支持持久化的，而guava是没有持久化功能的；分布式缓存如redis是有持久化功能的，memcached是没有持久化功能的；

**8.阻塞机制**

在看Mybatis源码的时候，二级缓存提供了一个blocking标识，表示当在缓存中找不到元素时，它设置对缓存键的锁定；这样其他线程将等待此元素被填充，而不是命中数据库；其实我们使用缓存的目的就是因为被缓存的数据生成比较费时，比如调用对外的接口，查询数据库，计算量很大的结果等等；这时候如果多个线程同时调用get方法获取的结果都为null，每个线程都去执行一遍费时的计算，其实也是对资源的浪费；最好的办法是只有一个线程去执行，其他线程等待，计算一次就够了；但是此功能基本上都交给使用者来处理，很少有本地缓存有这种功能；
